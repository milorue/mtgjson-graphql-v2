export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};

export type AtomicCard = {
  __typename?: 'AtomicCard';
  /** Name of the artist that illustrated the card art */
  artist?: Maybe<Scalars['String']>;
  /** List of the colors found in manaCost, colorIndicator, and text */
  colorIdentity?: Maybe<Array<Scalars['String']>>;
  /** List of all the colors in the color indicator (The symbol prefixed to a card's types) */
  colorIndicator?: Maybe<Array<Scalars['String']>>;
  /** List of all colors in manaCost, colorIndicator. Some cards may not have a value, such as cards with 'Devoid' in its text */
  colors?: Maybe<Array<Scalars['String']>>;
  /** The converted mana cost of the card */
  convertedManaCost?: Maybe<Scalars['Float']>;
  /** Card rank on EDHRec */
  edhrecRank?: Maybe<Scalars['Float']>;
  /** The converted mana cost of the face of either half or part of the card */
  faceConvertedManaCost?: Maybe<Scalars['Float']>;
  /** Name on the face of the card */
  faceName?: Maybe<Scalars['String']>;
  foreignData?: Maybe<Array<ForeignData>>;
  /** Starting maximum hand size total modifier. A plus or minus character proceeds an integer */
  hand?: Maybe<Scalars['String']>;
  /** If the card allows a value other than 4 copies in a deck */
  hasAlternativeDeckLimit?: Maybe<Scalars['Boolean']>;
  id: Scalars['String'];
  /** If the card is on the Magic: The Gathering Reserved List */
  isReserved?: Maybe<Scalars['Boolean']>;
  /** Type of card layout */
  layout?: Maybe<Scalars['String']>;
  /** See the Leadership Skills data model */
  leadershipSkills?: Maybe<LeadershipSkills>;
  /** See the Legalities data model */
  legalities?: Maybe<Legalities>;
  /** Starting life total modifier. A plus or minus character preceeds an integer. Used only on Vanguard cards */
  life?: Maybe<Scalars['String']>;
  /** Planeswalker loyalty value */
  loyalty?: Maybe<Scalars['String']>;
  /** Mana cost of the card */
  manaCost?: Maybe<Scalars['String']>;
  /** Names of each face on the card. Card with multiple faces, like 'Split' and 'Meld' cards are given as delimiter. Example: Face 1 Name // Face 2 Name */
  name?: Maybe<Scalars['String']>;
  /** Power of the card */
  power?: Maybe<Scalars['String']>;
  /** List of sets the card was printed in, in uppercase */
  printings?: Maybe<Array<Scalars['String']>>;
  /** See the Purchase Urls data model */
  purchaseUrls?: Maybe<PurchaseUrls>;
  /** See the Rulings data model */
  rulings?: Maybe<Array<Rulings>>;
  /** Identifier of the card side. Used on cards with multiple faces */
  side?: Maybe<Scalars['String']>;
  /** List of card subtypes found after em-dash */
  subTypes?: Maybe<Array<Scalars['String']>>;
  /** List of card supertypes found before em-dash */
  superTypes?: Maybe<Array<Scalars['String']>>;
  /** Rules text of the card */
  text?: Maybe<Scalars['String']>;
  /** Toughness of the card */
  toughness?: Maybe<Scalars['String']>;
  /** Type of the card as visible, including any supertypes and subtypes */
  type?: Maybe<Scalars['String']>;
  /** List of all 'card types' of the card, including Un-sets and gameplay variants */
  types?: Maybe<Array<Scalars['String']>>;
  /** A universal unique ID (v5) generated by MTGJSON. Each entry is unique */
  uuid: Scalars['String'];
};

export type Card = {
  __typename?: 'Card';
  /** Name of the artist that illustrated the card art */
  artist?: Maybe<Scalars['String']>;
  /** The ASCII (Basic/128) code formatted card name with no special unicode characters */
  asciiName?: Maybe<Scalars['String']>;
  /** List of the card's available printing types */
  availability?: Maybe<Array<Scalars['String']>>;
  /** Color of the card border */
  borderColor?: Maybe<Scalars['String']>;
  /** List of the colors found in manaCost, colorIndicator, and text */
  colorIdentity?: Maybe<Array<Scalars['String']>>;
  /** List of all the colors in the color indicator (The symbol prefixed to a card's types) */
  colorIndicator?: Maybe<Array<Scalars['String']>>;
  /** List of all colors in manaCost, colorIndicator. Some cards may not have a value, such as cards with 'Devoid' in its text */
  colors?: Maybe<Array<Scalars['String']>>;
  /** The converted mana cost of the card */
  convertedManaCost?: Maybe<Scalars['Float']>;
  /** How many of this card exists in a relevant deck */
  count?: Maybe<Scalars['Float']>;
  /** An indicator for which duel deck the card is in */
  duelDeck?: Maybe<Scalars['String']>;
  /** Card rank on EDHRec */
  edhrecRank?: Maybe<Scalars['Float']>;
  /** The converted mana cost of the face of either half or part of the card */
  faceConvertedManaCost?: Maybe<Scalars['Float']>;
  /** Name on the face of the card */
  faceName?: Maybe<Scalars['String']>;
  /** Promotional card name printed above the true card name on special cards that has no game function */
  flavorName?: Maybe<Scalars['String']>;
  /** Italicized text found below the rules text that has no game function */
  flavorText?: Maybe<Scalars['String']>;
  foreignData?: Maybe<Array<ForeignData>>;
  /** The visual frame effect */
  frameEffects?: Maybe<Array<Scalars['String']>>;
  /** Version of the card frame style */
  frameVersion?: Maybe<Scalars['String']>;
  /** Starting maximum hand size total modifier. A plus or minus character proceeds an integer */
  hand?: Maybe<Scalars['String']>;
  /** If the card allows a value other than 4 copies in a deck */
  hasAlternativeDeckLimit?: Maybe<Scalars['Boolean']>;
  /** If the card marked by Wizards of the Coast for having sensitive content. Cards with this property may have missing or degraded properties and values */
  hasContentWarning?: Maybe<Scalars['Boolean']>;
  /** If the card be found in foil */
  hasFoil?: Maybe<Scalars['Boolean']>;
  /** If the card can be found in non-foil */
  hasNonFoil?: Maybe<Scalars['Boolean']>;
  id: Scalars['String'];
  identifiers?: Maybe<Identifier>;
  /** The card has some kind of alternative variation to its printed counterpart */
  isAlternative?: Maybe<Scalars['Boolean']>;
  /** If the card is in foil */
  isFoil?: Maybe<Scalars['Boolean']>;
  /** If the card has full artwork */
  isFullArt?: Maybe<Scalars['Boolean']>;
  /** If the card is only available in Magic: The Gathering Online */
  isOnlineOnly?: Maybe<Scalars['Boolean']>;
  /** If the card is oversized */
  isOversized?: Maybe<Scalars['Boolean']>;
  /** If the card is promotional */
  isPromo?: Maybe<Scalars['Boolean']>;
  /** If the card has been reprinted */
  isReprint?: Maybe<Scalars['Boolean']>;
  /** If the card is on the Magic: The Gathering Reserved List */
  isReserved?: Maybe<Scalars['Boolean']>;
  /** If the card is found in a booster pack */
  isStarter?: Maybe<Scalars['Boolean']>;
  /** If the card has a story spotlight */
  isStorySpotlight?: Maybe<Scalars['Boolean']>;
  /** If the card does not have a text box */
  isTextless?: Maybe<Scalars['Boolean']>;
  /** If this card is 'timeshifted', a feature from Time Spiral block */
  isTimeshifted?: Maybe<Scalars['Boolean']>;
  /** All keywords found on a card */
  keywords?: Maybe<Array<Scalars['String']>>;
  /** Type of card layout */
  layout?: Maybe<Scalars['String']>;
  /** See the Leadership Skills data model */
  leadershipSkills?: Maybe<LeadershipSkills>;
  /** See the Legalities data model */
  legalities?: Maybe<Legalities>;
  /** Starting life total modifier. A plus or minus character preceeds an integer. Used only on Vanguard cards */
  life?: Maybe<Scalars['String']>;
  /** Planeswalker loyalty value */
  loyalty?: Maybe<Scalars['String']>;
  /** Mana cost of the card */
  manaCost?: Maybe<Scalars['String']>;
  /** Names of each face on the card. Card with multiple faces, like 'Split' and 'Meld' cards are given as delimiter. Example: Face 1 Name // Face 2 Name */
  name?: Maybe<Scalars['String']>;
  /** Number of the card. Can be prefixed or suffixed with a * or other characters for promo sets */
  number?: Maybe<Scalars['String']>;
  /** Text on the card as originally printed */
  originalText?: Maybe<Scalars['String']>;
  /** Type as originally printed. Includes any supertypes and subtypes */
  originalType?: Maybe<Scalars['String']>;
  /** List of UUID's of this card with counterparts, such as transformed or melded faces */
  otherFaceIds?: Maybe<Array<Scalars['String']>>;
  /** Power of the card */
  power?: Maybe<Scalars['String']>;
  /** List of sets the card was printed in, in uppercase */
  printings?: Maybe<Array<Scalars['String']>>;
  /** List of promotional types for a card */
  promoTypes?: Maybe<Array<Scalars['String']>>;
  /** See the Purchase Urls data model */
  purchaseUrls?: Maybe<PurchaseUrls>;
  /** Card printing rarity */
  rarity?: Maybe<Scalars['String']>;
  /** See the Rulings data model */
  rulings?: Maybe<Array<Rulings>>;
  /** The set code that the card is from */
  setCode?: Maybe<Scalars['String']>;
  /** Identifier of the card side. Used on cards with multiple faces */
  side?: Maybe<Scalars['String']>;
  /** List of card subtypes found after em-dash */
  subTypes?: Maybe<Array<Scalars['String']>>;
  /** List of card supertypes found before em-dash */
  superTypes?: Maybe<Array<Scalars['String']>>;
  /** Rules text of the card */
  text?: Maybe<Scalars['String']>;
  /** Toughness of the card */
  toughness?: Maybe<Scalars['String']>;
  /** Type of the card as visible, including any supertypes and subtypes */
  type?: Maybe<Scalars['String']>;
  /** List of all 'card types' of the card, including Un-sets and gameplay variants */
  types?: Maybe<Array<Scalars['String']>>;
  /** A universal unique ID (v5) generated by MTGJSON. Each entry is unique */
  uuid: Scalars['String'];
  /** List of UUID's of this card with alternate printings in the same set. Excludes Un-sets */
  variation?: Maybe<Array<Scalars['String']>>;
  /** Name of the watermark on the card */
  watermark?: Maybe<Scalars['String']>;
};

export type CardGetInput = {
  artist?: Maybe<Scalars['String']>;
  asciiName?: Maybe<Scalars['String']>;
  availability?: Maybe<Array<Scalars['String']>>;
  borderColor?: Maybe<Scalars['String']>;
  colorIdentity?: Maybe<Array<Scalars['String']>>;
  colorIndicator?: Maybe<Array<Scalars['String']>>;
  colors?: Maybe<Array<Scalars['String']>>;
  convertedManaCost?: Maybe<Scalars['Float']>;
  count?: Maybe<Scalars['Float']>;
  duelDeck?: Maybe<Scalars['String']>;
  edhrecRank?: Maybe<Scalars['Float']>;
  faceConvertedManaCost?: Maybe<Scalars['Float']>;
  faceName?: Maybe<Scalars['String']>;
  flavorName?: Maybe<Scalars['String']>;
  flavorText?: Maybe<Scalars['String']>;
  frameEffects?: Maybe<Scalars['String']>;
  frameVersion?: Maybe<Scalars['String']>;
  hand?: Maybe<Scalars['String']>;
  hasAlternativeDeckLimit?: Maybe<Scalars['Boolean']>;
  hasContentWarning?: Maybe<Scalars['Boolean']>;
  hasFoil?: Maybe<Scalars['Boolean']>;
  hasNonFoil?: Maybe<Scalars['Boolean']>;
  isAlternative?: Maybe<Scalars['Boolean']>;
  isFoil?: Maybe<Scalars['Boolean']>;
  isFullArt?: Maybe<Scalars['Boolean']>;
  isOnlineOnly?: Maybe<Scalars['Boolean']>;
  isOversized?: Maybe<Scalars['Boolean']>;
  isPromo?: Maybe<Scalars['Boolean']>;
  isReprint?: Maybe<Scalars['Boolean']>;
  isReserved?: Maybe<Scalars['Boolean']>;
  isStarter?: Maybe<Scalars['Boolean']>;
  isStorySpotlight?: Maybe<Scalars['Boolean']>;
  isTextless?: Maybe<Scalars['Boolean']>;
  isTimeshifted?: Maybe<Scalars['Boolean']>;
  keywords?: Maybe<Array<Scalars['String']>>;
  layout?: Maybe<Scalars['String']>;
  life?: Maybe<Scalars['String']>;
  loyalty?: Maybe<Scalars['String']>;
  manaCost?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['String']>;
  originalText?: Maybe<Scalars['String']>;
  originalType?: Maybe<Scalars['String']>;
  power?: Maybe<Scalars['String']>;
  printings?: Maybe<Array<Scalars['String']>>;
  promoTypes?: Maybe<Array<Scalars['String']>>;
  rarity?: Maybe<Scalars['String']>;
  setCode?: Maybe<Scalars['String']>;
  side?: Maybe<Scalars['String']>;
  subTypes?: Maybe<Array<Scalars['String']>>;
  superTypes?: Maybe<Array<Scalars['String']>>;
  text?: Maybe<Scalars['String']>;
  toughness?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  types?: Maybe<Array<Scalars['String']>>;
  uuid?: Maybe<Scalars['String']>;
  variation?: Maybe<Array<Scalars['String']>>;
  watermark?: Maybe<Scalars['String']>;
};

export type CardToken = {
  __typename?: 'CardToken';
  /** Name of the artist that illustrated the card art */
  artist?: Maybe<Scalars['String']>;
  /** The ASCII (Basic/128) code formatted card name with no special unicode characters */
  asciiName?: Maybe<Scalars['String']>;
  /** List of the card's available printing types */
  availability?: Maybe<Array<Scalars['String']>>;
  /** Color of the card border */
  borderColor?: Maybe<Scalars['String']>;
  /** List of the colors found in manaCost, colorIndicator, and text */
  colorIdentity?: Maybe<Array<Scalars['String']>>;
  /** List of all the colors in the color indicator (The symbol prefixed to a card's types) */
  colorIndicator?: Maybe<Array<Scalars['String']>>;
  /** List of all colors in manaCost, colorIndicator. Some cards may not have a value, such as cards with 'Devoid' in its text */
  colors?: Maybe<Array<Scalars['String']>>;
  /** Card rank on EDHRec */
  edhrecRank?: Maybe<Scalars['Float']>;
  /** Name on the face of the card */
  faceName?: Maybe<Scalars['String']>;
  /** Italicized text found below the rules text that has no game function */
  flavorText?: Maybe<Scalars['String']>;
  /** The visual frame effect */
  frameEffects?: Maybe<Array<Scalars['String']>>;
  /** Version of the card frame style */
  frameVersion?: Maybe<Scalars['String']>;
  /** If the card be found in foil */
  hasFoil?: Maybe<Scalars['Boolean']>;
  /** If the card can be found in non-foil */
  hasNonFoil?: Maybe<Scalars['Boolean']>;
  identifiers?: Maybe<Identifier>;
  /** If the card has full artwork */
  isFullArt?: Maybe<Scalars['Boolean']>;
  /** If the card is only available in Magic: The Gathering Online */
  isOnlineOnly?: Maybe<Scalars['Boolean']>;
  /** If the card is promotional */
  isPromo?: Maybe<Scalars['Boolean']>;
  /** If the card has been reprinted */
  isReprint?: Maybe<Scalars['Boolean']>;
  /** All keywords found on a card */
  keywords?: Maybe<Array<Scalars['String']>>;
  /** Type of card layout */
  layout?: Maybe<Scalars['String']>;
  /** Planeswalker loyalty value */
  loyalty?: Maybe<Scalars['String']>;
  /** Names of each face on the card. Card with multiple faces, like 'Split' and 'Meld' cards are given as delimiter. Example: Face 1 Name // Face 2 Name */
  name?: Maybe<Scalars['String']>;
  /** Number of the card. Can be prefixed or suffixed with a * or other characters for promo sets */
  number?: Maybe<Scalars['String']>;
  /** Power of the card */
  power?: Maybe<Scalars['String']>;
  /** List of promotional types for a card */
  promoTypes?: Maybe<Array<Scalars['String']>>;
  /** The names of the cards that product this card */
  reverseRelated?: Maybe<Array<Scalars['String']>>;
  /** The set code that the card is from */
  setCode?: Maybe<Scalars['String']>;
  /** Identifier of the card side. Used on cards with multiple faces */
  side?: Maybe<Scalars['String']>;
  /** List of card subtypes found after em-dash */
  subTypes?: Maybe<Array<Scalars['String']>>;
  /** Rules text of the card */
  text?: Maybe<Scalars['String']>;
  /** Toughness of the card */
  toughness?: Maybe<Scalars['String']>;
  /** Type of the card as visible, including any supertypes and subtypes */
  type?: Maybe<Scalars['String']>;
  /** List of all 'card types' of the card, including Un-sets and gameplay variants */
  types?: Maybe<Array<Scalars['String']>>;
  /** A universal unique ID (v5) generated by MTGJSON. Each entry is unique */
  uuid: Scalars['String'];
  /** Name of the watermark on the card */
  watermark?: Maybe<Scalars['String']>;
};

export type Deck = {
  __typename?: 'Deck';
  /** Set code for the deck */
  code?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  /** The cards in the main-board. See the Card data model */
  mainBoard?: Maybe<Array<Card>>;
  /** Name of the deck */
  name?: Maybe<Scalars['String']>;
  /** Release date in ISO 8601 format for the set. Returns null if the set was not formally released as a product. */
  releaseDate?: Maybe<Scalars['String']>;
  /** The cards in the side-board. See the Card data model */
  sideBoard?: Maybe<Array<Card>>;
  /** The type of deck */
  type?: Maybe<Scalars['String']>;
};

export type DeckGetInput = {
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

export type DeckList = {
  __typename?: 'DeckList';
  /** Set code for the deck */
  code: Scalars['String'];
  /** File name for the deck. Combines the name and code fields to avoid namespace collisions. */
  fileName?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  /** Name of the deck */
  name?: Maybe<Scalars['String']>;
  /** Release date in ISO 8601 format for the set. Returns null if the set was not formally released as a product. */
  releaseDate?: Maybe<Scalars['String']>;
};

export type ForeignData = {
  __typename?: 'ForeignData';
  /** Name on the face of the card */
  faceName?: Maybe<Scalars['String']>;
  /** Flavor text in foreign language */
  flavorText?: Maybe<Scalars['String']>;
  /** Foreign language of card */
  language: Scalars['String'];
  /** Multiverse ID of the card */
  multiverseId?: Maybe<Scalars['String']>;
  /** Name of the card in foreign language */
  name?: Maybe<Scalars['String']>;
  /** Text ruling of the card in foreign language */
  text?: Maybe<Scalars['String']>;
  /** Type of the card. Includes any supertypes and subtypes */
  type?: Maybe<Scalars['String']>;
};

export type Identifier = {
  __typename?: 'Identifier';
  /** The Card Kingdom card foil ID */
  cardKingdomFoilId?: Maybe<Scalars['String']>;
  /** The Card Kingdom card ID */
  cardKingdomId?: Maybe<Scalars['String']>;
  /** The Card Market card ID */
  mcmId?: Maybe<Scalars['String']>;
  /** The Card Market card meta ID */
  mcmMetaId?: Maybe<Scalars['String']>;
  /** The Magic: The Gathering Arena card ID */
  mtgArenaId?: Maybe<Scalars['String']>;
  /** A universal unique ID generated by MTGJSON. Each entry is unique. Entries are for MTGJSON v4 uuid generation */
  mtgjsonV4Id: Scalars['String'];
  /** The Magic: The Gathering Online card foil ID */
  mtgoFoilId?: Maybe<Scalars['String']>;
  /** The Magic: The Gathering Online card ID */
  mtgoId?: Maybe<Scalars['String']>;
  /** An string cards have which Wizards of the Coast uses as a card identifier */
  multiverseId?: Maybe<Scalars['String']>;
  /** A universal unique ID generated by Scryfall. Note that cards with multiple faces are not unique */
  scryfallId: Scalars['String'];
  /** A unique identifier for the card artwork that remains consistent across reprints. Newly spoiled cards may not have this field yet */
  scryfallIllustrationId?: Maybe<Scalars['String']>;
  /** A unique ID for this card's oracle identity. This value is consistent across reprinted card editions, and unique among different cards with the same name (tokens, Unstable variants, etc) */
  scryfallOracleId?: Maybe<Scalars['String']>;
  /** The TCG Player card ID */
  tcgplayerProductId?: Maybe<Scalars['String']>;
};

export type LeadershipSkills = {
  __typename?: 'LeadershipSkills';
  /** If this card can be your commander in the Brawl format */
  brawl?: Maybe<Scalars['Boolean']>;
  /** If this card can be your commander in the Commander/EDH format */
  commander?: Maybe<Scalars['Boolean']>;
  /** If this card can be your commander in the Oathbreaker format */
  oathbreaker?: Maybe<Scalars['Boolean']>;
};

export type Legalities = {
  __typename?: 'Legalities';
  format?: Maybe<LegalitiesFormat>;
  status?: Maybe<Scalars['String']>;
  uuid?: Maybe<Card>;
};

export enum LegalitiesFormat {
  Brawl = 'BRAWL',
  Commander = 'COMMANDER',
  Duel = 'DUEL',
  Frontier = 'FRONTIER',
  Future = 'FUTURE',
  Legacy = 'LEGACY',
  Modern = 'MODERN',
  Pauper = 'PAUPER',
  Penny = 'PENNY',
  Pioneer = 'PIONEER',
  Standard = 'STANDARD',
  Vintage = 'VINTAGE'
}

export enum ListOrder {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type ListOrderInput = {
  order: ListOrder;
};

export type Meta = {
  __typename?: 'Meta';
  /** ISO 8601 date of the MTGJSON build. */
  date?: Maybe<Scalars['String']>;
  /** The postgres MTGJSON database iteration */
  dbVersion?: Maybe<Scalars['Float']>;
  id: Scalars['String'];
  /** SemVer specification of the MTGJSON build. */
  version?: Maybe<Scalars['String']>;
};

export type PaginationInput = {
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export type PurchaseUrls = {
  __typename?: 'PurchaseUrls';
  /** URL to purchase a product on Card Kingdom */
  cardKingdom?: Maybe<Scalars['String']>;
  /** URL to purchase a foil product on Card Kingdom */
  cardKingdomFoil?: Maybe<Scalars['String']>;
  /** URL to purchase a product on Cardmarket */
  cardmarket?: Maybe<Scalars['String']>;
  /** URL to purchase a product on TCG Player */
  tcgplayer?: Maybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  /** Retrieve all cards with given criterias */
  cards: Array<Card>;
  /** Retrieve a deck given a deck code or name */
  decks: Deck;
  metadata: Meta;
  /** Retrieves a given list of sets based on criteria */
  sets: Array<Set>;
  status: Scalars['Boolean'];
};


export type QueryCardsArgs = {
  input: CardGetInput;
  order: ListOrderInput;
  page: PaginationInput;
};


export type QueryDecksArgs = {
  input: DeckGetInput;
};


export type QuerySetsArgs = {
  input: SetGetInput;
  order: ListOrderInput;
  page: PaginationInput;
};

export type Rulings = {
  __typename?: 'Rulings';
  /** Release date in ISO 8601 format for the rule */
  date?: Maybe<Scalars['String']>;
  /** Text ruling of the card */
  text?: Maybe<Scalars['String']>;
};

export type Set = {
  __typename?: 'Set';
  /** Number of cards in the set. Will default to totalSetSize if not available. Note that Wizards sometimes prints extra cards beyond the set size into promos or supplemental products. */
  baseSetSize?: Maybe<Scalars['Float']>;
  /** Block name the set was in */
  block?: Maybe<Scalars['String']>;
  /** List of cards in this set. See the Card data model */
  cards?: Maybe<Array<Card>>;
  /** Set code for the set */
  code?: Maybe<Scalars['String']>;
  /** Alternate set code Wizards uses for a select few duel deck sets. */
  codeV3?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  /** If this set is only available in foil */
  isFoilOnly?: Maybe<Scalars['Boolean']>;
  /** If this set is available only outside the United States */
  isForeignOnly?: Maybe<Scalars['Boolean']>;
  /** If this set is only available in non-foil */
  isNonFoilOnly?: Maybe<Scalars['Boolean']>;
  /** If this set is only available in Magic: The Gathering Online */
  isOnlineOnly?: Maybe<Scalars['Boolean']>;
  /** If this set is only available in paper */
  isPaperOnly?: Maybe<Scalars['Boolean']>;
  /** If this set is still in preview (spoiled). Preview sets do not have complete data. */
  isPartialPreview?: Maybe<Scalars['Boolean']>;
  /** The matching keyrune code for Keyrune image icons */
  keyruneCode?: Maybe<Scalars['String']>;
  /** The Magic Card Market set ID */
  mcmId?: Maybe<Scalars['Float']>;
  /** The Magic Card Market set name */
  mcmName?: Maybe<Scalars['String']>;
  /** Set code for the set as it appears on Magic: The Gathering Online. */
  mtgoCode?: Maybe<Scalars['String']>;
  /** Name of the set. */
  name?: Maybe<Scalars['String']>;
  /** The parent set code for set variations like promotions, guild kits, etc */
  parentCode?: Maybe<Scalars['String']>;
  /** Release date in ISO 8601 format for the set */
  releaseDate?: Maybe<Scalars['String']>;
  /** Group ID of the set on TCGPlayer */
  tcgplayerGroupId?: Maybe<Scalars['Float']>;
  /** Tokens available to the set. See the Card (Token) data model */
  tokens?: Maybe<Array<CardToken>>;
  /** Total number of cards in the set, including promos and related supplemental products */
  totalSetSize?: Maybe<Scalars['Float']>;
  /** Translated set name by language. See the Translation data model */
  translations?: Maybe<Translations>;
  /** Expansion type of the set */
  type?: Maybe<Scalars['String']>;
};

export type SetGetInput = {
  block?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  keyruneCode?: Maybe<Scalars['String']>;
  mcmId?: Maybe<Scalars['Float']>;
  mcmName?: Maybe<Scalars['String']>;
  mtgoCode?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  parentCode?: Maybe<Scalars['String']>;
  releaseDate?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

export type SetList = {
  __typename?: 'SetList';
  /** Number of cards in the set. Will default to totalSetSize if not available. Note that Wizards sometimes prints extra cards beyond the set size into promos or supplemental products. */
  baseSetSize?: Maybe<Scalars['Float']>;
  /** Set code for the set */
  code?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  /** If this set is only available in foil */
  isFoilOnly?: Maybe<Scalars['Boolean']>;
  /** If this set is only available in Magic: The Gathering Online */
  isOnlineOnly?: Maybe<Scalars['Boolean']>;
  /** If this set is only available in paper */
  isPaperOnly?: Maybe<Scalars['Boolean']>;
  /** Name of the set. */
  name?: Maybe<Scalars['String']>;
  /** Release date in ISO 8601 format for the set */
  releaseDate?: Maybe<Scalars['String']>;
  /** Total number of cards in the set, including promos and related supplemental products */
  totalSetSize?: Maybe<Scalars['Float']>;
  /** Expansion type of the set */
  type?: Maybe<Scalars['String']>;
};

export type Translations = {
  __typename?: 'Translations';
  AncientGreek?: Maybe<Scalars['String']>;
  Arabic?: Maybe<Scalars['String']>;
  ChineseSimplified?: Maybe<Scalars['String']>;
  ChineseTraditional?: Maybe<Scalars['String']>;
  French?: Maybe<Scalars['String']>;
  German?: Maybe<Scalars['String']>;
  Hebrew?: Maybe<Scalars['String']>;
  Italian?: Maybe<Scalars['String']>;
  Japanese?: Maybe<Scalars['String']>;
  Korean?: Maybe<Scalars['String']>;
  Latin?: Maybe<Scalars['String']>;
  Phyrexian?: Maybe<Scalars['String']>;
  PortugueseBrazil?: Maybe<Scalars['String']>;
  Russian?: Maybe<Scalars['String']>;
  Sanskrit?: Maybe<Scalars['String']>;
  Spanish?: Maybe<Scalars['String']>;
};
